<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="海纳百川 有容乃大 壁立千仞 无欲则刚">
<meta property="og:type" content="website">
<meta property="og:title" content="XL&#39;Blogs">
<meta property="og:url" content="https://xhdlmy.github.io/index.html">
<meta property="og:site_name" content="XL&#39;Blogs">
<meta property="og:description" content="海纳百川 有容乃大 壁立千仞 无欲则刚">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="XL&#39;Blogs">
<meta name="twitter:description" content="海纳百川 有容乃大 壁立千仞 无欲则刚">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '2FIA5CRNSO',
      apiKey: 'e4862257cee716da51316339f64f39d8',
      indexName: 'dev_blog',
      hits: {"per_page":10},
      labels: {"input_placeholder":"输入关键字搜索","hits_empty":"没有找到与 ${query} 相关内容","hits_stats":"搜索到 ${hits} 条相关内容"}
    }
  };
</script>



  <link rel="canonical" href="https://xhdlmy.github.io/"/>





  <title>XL'Blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XL'Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
			
			
			
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xhdlmy.github.io/2018/10/25/焦虑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee&Da">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/kuiba_dacang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XL'Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/焦虑/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-25T16:20:54+08:00">
                2018-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、认识我的对手——焦虑 （我是轻微的焦虑）</p>
<p>焦虑：是指对未来会担心有不好的事情发生。担心的东西多种多样，担心失败、担心被否定、被贬低……以无意识的、快速的、习惯性的思维逻辑推理、画面想像的形式存在，引发焦虑情绪体验。焦虑情绪同时也在推动者上诉思维形式；思维方式和情绪感受交互影响，相互促进，恶性循环。</p>
<p>二、我的对手伤害我的方式</p>
<p>焦虑这个小恶魔<br>入侵我的思维上：是担心有不好的事情会发生，我确实一直在担心。<br>入侵我的情绪中：是紧张、不安<br>反映在我的身体上：肠胃不适，肩颈僵硬<br>反应在我的表现上：瞻前顾后，犹豫不决<br>反应在我的人际关系上：敏感、多疑、回避</p>
<p>三、焦虑形成的原因</p>
<p>从小到大的家庭教育、后期生活经验，造成当事人内心自卑、缺乏自信心和安全感，遇到事情容易焦虑，渴望成功和优秀，害怕失败和犯错。<br>一般焦虑者有很强烈的控制欲，额，目前还好。</p>
<p>四、我要和你面对面</p>
<p>不逃避</p>
<p>你想控制我的想法，我就从我的想法开始：</p>
<p>察觉：</p>
<p>觉察自己的思维活动过程：</p>
<p>觉察自己的情绪变化和身体反应。做一些事情轻松、愉悦自己的身心。<br>情绪和身体反应的变化也会引起思维的变化，所以一定满足自己的身心需求……</p>
<p>做自己感兴趣、擅长的事情：更容易专注进去、更容易取得成效、进而可以获得轻松、愉悦、自信的感觉。</p>
<p>在我察觉后，我也可以写觉知日记：</p>
<pre><code>2018.10.25

在明确了自己的问题之后，上午先来公司，希望同事能明白我的困惑，
我确实明白了问题是在我的心这儿，当工作时间同事开始闲聊时，我已经意识到，并立马开始紧张，
想利用昨天学习到的知识来抵抗、对抗这种环境，想急切证明 R.A.I.N 方法是有效的，想证明以后碰到这种环境我也是OK的，总的来说，
我想成功，想彻底改变这种现状。当一次对抗失败后（并没有投入到想要敲的代码中，主要是思维混乱，自己也认为这个不好搞，需要静下心来，每念及此，我都觉得对抗一定是失败的），
我之前是害怕他们下一回合的谈论，在第一次对抗失败，我今天反而想尽快他们来第二轮谈话，我急于想证明我是能做到的，显然一个上午过去了，基本是失败的。但是也发现了一个
比之前好的情况，我至少完成了一项任务，虽然还是觉得因为他们的对话，或者现在看来，是你这个小恶魔带来的影响我的思维的，让我效率低下。

对的，我的确害怕效率低下，你正是明白我急切想成功，所以你更容易得手对吧。

下午呢，我一如既往的焦虑，因为我明白我上午对抗失败，下午也应该是失败的，我真的不想怀疑我昨天看到的“方法”失效，会对你毫无抵抗之力。

但就当我沮丧的时候，想学习 ButterKnife 的时候，发现还是无法静下心来，于是我又 Google ，想来找到治愈你的办法。

我单刀直入，直切主题，搜索“对声音敏感的人” 发现了我确实被你控制了，但我目前觉得我能安抚好你，或者说说服你不让你在以后伤害我。

世人告诉我，这是一种心理障碍，恩，我承认，但我并不害怕，我明白之前的很多事件都是如此。

我要学会自我暗示，我不认为我是“神经衰弱”，你也休想让我担心我有什么毛病，我从现在开始，有意识无意识的自律，像我的朋友伟华一样，像圣人一样；
我还有朋友罗兴旺的帮助，我可以联合一切我可以联合一切的力量来治愈你。对不起，差点忘了，我还有一个超级值得我去爱的老婆，她会在治愈你的过程中
起到很大的作用的，她有爱人的力量。

现在我在网上找到一个 于飞-知乎 的心理咨询师，我来免费学习，对就是更好的认识你，于是你就这样被我记录下来了。

于飞说我这是 强迫症心理 喔喔，被发现了

是这样形容的:我对周围的声音敏感，也就是说越是不想注意，不想感到心烦，就越做不到，就越是会注意。 （确实，这有点棘手）
</code></pre><p>有一句话是这样说的：</p>
<pre><code>越是抗拒的、拒绝的，就越是会持续的存在，而且只会越来越强大。
</code></pre><p>我对同事的声音敏感，是因为你，对的，我被你控制了，你让我对我的同事们的声音是有敌意的，有了敌意，就是想对抗。</p>
<p>首先，我先允许我的同事说话，不仅如此，我还要为他们说话，虽然我得吐槽说，（每当同事说话的时候，我要对自己说，慢下来、慢下来）<br>虽然他们说话的声音大，而且内容在我看来大多是无意义的，但是从他们的角度来看，也不乏是有原因的。（比如，大家要聊孩子的事情；<br>有了孩子想分享孩子的生活点滴，恩恩，这个我可以理解的），还有车，股票等。我确实觉得他们每天说的话都是类似的，在我看来，可能都是无意义的。</p>
<p>我实在做不到充耳不闻，而且他们有时突然声音很大，或者笑声不断，我都没法理解，是因为代沟吗？</p>
<p>他们聊天是有原因的，A同事大多是确实时间多，如果一天下来不说话，也确实不显示，如果我舒服了，他肯定也憋得慌，会不会？B同事在我看来也是一个容易被情绪影响的人，<br>他刚买了车，喜欢说跟车有关的，而且他情绪很容易被点燃，我是否也能帮助到他？如果我能把你搞定的话。C同事，是个女同事，我想，这也是办公室经常说话的原因了，有异性，总是<br>可以创造良好的办公室氛围的。恩，我觉得我们办公室的氛围还不错。</p>
<p>说完以上，在重复一遍，先允许我的同事说话，然后我也允许我自己 目前还会关注或者说持续关注他们说话的声音。<br>在写的时候，我发现我对这样的声音的敏感度降低了很多，至少我能笔走龙蛇来描述你。</p>
<p>明白一点，这个是我们无法回避的，只能选择包容。是真的只能选择包容，那么就是昨天说的慈善了。我不妨试着和同事的聊天和平相处，我把他们都拟人化，当做自己的朋友。<br>额，这个貌似真没试过。我依稀记得，我之前有很多很多的不如意，我都没有很好的处理，有的处理了，有的没处理。</p>
<p>说多了，我直接说我该尝试怎么办：</p>
<ul>
<li>从内心允许他们聊天，试着同理心去感受</li>
<li>允许自己会受到他们的影响，会关注，不抗拒，不抗拒的意思不是忍受，是接受，恩，这很重要，我真是天才。承认不可能一蹴而就，除非我已经化敌为友</li>
<li>允许自己的注意力会分散。自己在这样的对同事聊天内容的敏感和在意的状态里，自己的注意力势必就会被分散，先允许自己的注意力会被分散，允许自己做事情还不够专心，效率还不高。</li>
<li>继续做自己手里的事情（终于说到关键了，你知道，这是我最难做到的了，也正是因为暂时无法做到，所以才有了以上问题，正所谓恶性循环是也。）</li>
<li>我不跟你对抗，你利用这些声音产生一些不好的情绪想来影响我的思绪，我不跟你正面刚，我知道你越是提醒我，你看，他们又在说话了，还可能持续下去，我就越是中了你的陷阱。我努努力，把自己需要做的，想要做的事情做起来，我相信另一个做事情的小天使会慢慢给我带来新的、不一样的感觉。</li>
<li>尽量做一些让自己感到轻松有趣的事情，对，对我的小天使好一点，不要让它做一些比较比较繁重的任务。感受它带来的好处。</li>
<li>允许自己目前还做不好的事情，慢慢来，放松，放宽心，一切都会好起来的，正所谓，道，船到桥头自然直（突然感觉这句话很有哲理，船总会到岸的，你的焦虑只会影响你的旅途这一段的心情，不会改变船前进的方向和目的地）</li>
</ul>
<p>我今天已经记录了自己的思维和想法，检验其真实性与合理性，对过去、现在、未来的自己、他人、环境重新进行解读，<br>用更正式、合理的想法代替原有的思维。</p>
<p>预设：明日他们还是会进行生活上的交谈与分享，也一定会影响到我，我该做什么？做简单一点的事情，那就是学习 Java 后端了。<br>我，明日应该清楚地认识到你带给我的影响，不盲目乐观，不盲目让你牵着鼻子走。</p>
<p>重建想法的具体的过程：</p>
<ul>
<li>我感到焦虑了，刚才发生了什么？ <ul>
<li>不用说了，一定是他们说话了，或者一来公司我就认为他们即将说话</li>
</ul>
</li>
<li>我想到了什么？ <ul>
<li>他们为什么不顾及他人感受？为什么不能“己所不欲，勿施于人”？</li>
<li>我肯定又无法好好学习了？</li>
<li>不能好好学习，我就不能在可见的未来寻求一个好价位？</li>
<li>我需要 money ability</li>
</ul>
</li>
<li>我为什么会这么想？<ul>
<li>我的思维就是如此</li>
</ul>
</li>
<li>我这么想的依据是什么？<ul>
<li>过去的经验告诉我的，明天一定会是这样</li>
</ul>
</li>
<li>我还可以怎么想？<ul>
<li>我能否在受不了的时候再次跟他们沟通？  </li>
</ul>
</li>
<li>我怎么想更合理？</li>
<li>我的想法改变后，我的感觉怎么样？</li>
</ul>
<h1 id="从行为上开始康复"><a href="#从行为上开始康复" class="headerlink" title="从行为上开始康复"></a>从行为上开始康复</h1><p>觉察自己的回避、退缩和拖延的行为习惯。</p>
<p>越是逃避的，越是焦虑和恐惧。</p>
<p>寻求依赖、抱怨他人，会加重自己的焦虑。</p>
<p>一个是认为自己无力面对和解决，必须要依靠他人，再一个是别人并不欠自己的，也无法为自己承担，所以也会拒绝。</p>
<p>勇敢的面对问题和循序渐进的解决问题，能够提升自信心。往往在面对了之后就会发现，原来它也不过如此。<br>很多问题要解决起来都是需要时间和过程的，如果总是想用最快的方式最好的解决问题，往往就会面临失败，而且还会受到伤害，<br>失去面对和解决问题的信心和勇气。</p>
<p>在过去的负性生活经验（他人的否定、自己的失败）及所形成的自我概念（自己是无能、没价值的）的阴云的笼罩之下，就是真正的自己，是与生俱来的、本源的乐观、自信和勇敢。清晰的认识到自己过去的生活经验及所形成的自我概念（包括对自己、他人和事物发展变化的认识）对自己当前的思维方式、情绪感受和行为做法的影响。拨开云层，看见真正的自己。如果没有了那层阴云（担心、害怕、自卑、不安）自己会是什么样？担心、害怕的背后是“我无能、没价值”的自我概念，在自我概念的背后是过去他人的否定、自己的失败，这些都不是真正的自己。</p>
<p>真正的自己，是与生俱来的、本源的乐观、自信和勇敢。</p>
<p><strong>记住：慢就是快，快就是慢！我的天呐，够了够了。</strong></p>
<p>提高自我觉察的能力，觉察在焦虑发作时的思维活动的形式、情绪变化、身体反应和外在表现，认识到它们之间的联系，分别调整。可以提前进行想象预演，闭上眼睛，设计一个让自己感到焦虑和产生焦虑症状的情境，放慢呼吸、放慢时间，看到其中的思维活动过程、情绪变化、身体反应和外在表现，看到它们之间的相互影响，依次进行调整，发现、调整、暗示、实践……</p>
<p>如果把人的心理比喻成一部电脑，自己的观念、思想、情绪感受和行为习惯就好比是事先设计好的程式。当事人的原有程式出现了BUG，需要修复，可以把新的观念、思想、情绪感受和行为做法设计进去，或者设计一个更高的智能，让当事人在“不清醒”的疑病状态里的时候，高级智能就会来提醒他认识到思维的虚假性，从而从“不清醒”的疑病状态转回到“清醒”的现实状态。这项工作需要在心理咨询中，由心理咨询师带领当事人通过问题解析、认知重建、行为训练和催眠暗示来逐步的实现。</p>
<p>— 陷阱流沙</p>
<p>陷阱流沙的人：有一个人陷进了流沙里，他非常的恐惧，不停的挣扎，可是越挣扎就陷得越深，他也知道自己要平静下来想办法出去，他也尝试过停止挣扎，可是要出去并不是一件容易的事情，他还在不停的下陷，他非常的焦急和恐惧，只能继续挣扎以试图摆脱危险和恐惧，最后被流沙淹没。有心理问题的人就像陷进流沙的人，不停的挣扎试图摆脱问题，然而越陷越深，后来听说要停止挣扎才能得救，但尝试之后发现还是出不去，就又继续挣扎试图逃脱。要出去是一个过程，需要足够的耐心，在这个过程里要接纳危险和恐惧，明确自己的目标是要出来，然后想办法实现目标，发现和寻求一切可以利用的资源帮助自己出来。慢即是快。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xhdlmy.github.io/2018/10/25/2.5 ButterKnife源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee&Da">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/kuiba_dacang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XL'Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/2.5 ButterKnife源码解析/" itemprop="url">APT编程 ButterKnife</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-25T15:14:23+08:00">
                2018-10-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>ButterKnife 注解在 编译时期会生成 “_ViewBinding” java 文件，这个工作是 <code>butterknife-compiler</code> 完成，这个过程就是 Annotation Process Tool 处理工具该做的事情！</p>
</blockquote>
<p>ButterKnife 工作流程：</p>
<ul>
<li>编译期间：（需要 APT 工作三件套）<ul>
<li>butterknife-compiler 处理具有 ButterKnife 注解的 java 文件，执行 process 方法，生成文件 </li>
</ul>
</li>
<li>运行期间：<ul>
<li>首先 Activity 触发 ButterKnife.bind(this)</li>
<li>通过反射手段来实例化 _ViewBinding 对象，在构造器中完成 Activity 与 View 的绑定</li>
</ul>
</li>
</ul>
<h1 id="运行时期"><a href="#运行时期" class="headerlink" title="运行时期"></a>运行时期</h1><p>Activity bind View </p>
<p>一般是 BaseActivity 的 onCreate 方法中使用 <code>ButterKnife.bind(this);</code> 简化如下：</p>
<pre><code>@NonNull @UiThread
  public static Unbinder bind(@NonNull Object target, @NonNull View source) {
    // 运行过程也有反射，是不是也影响运行效率
    Class&lt;?&gt; targetClass = target.getClass();
    // 所生成的 XxxActivity_ViewBinding implements Unbinder
    Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);

    if (constructor == null) {
      return Unbinder.EMPTY;
    }

    // 生成的 XxxActivity_ViewBinding 的构造方法就完成了 findViewById setOnClickListener
      return constructor.newInstance(target, source);

  }

@Nullable @CheckResult @UiThread
  private static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) {
    // BINDINGS 就是一个 Map Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = new LinkedHashMap&lt;&gt;();
    Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);
    // 如果一个 Activity 重新 onCreate，那么就将 Constructor 取出来
    if (bindingCtor != null) {
      if (debug) Log.d(TAG, &quot;HIT: Cached in binding map.&quot;);
      return bindingCtor;
    }
    // 第一次 BindView 就会通过 ClassLoader 来获得 Class
    String clsName = cls.getName();
      // Class.for(&quot;clsName + &quot;_ViewBinding&quot;&quot;); 也是 ClassLoader.loadClass(&quot;clsName + &quot;_ViewBinding&quot;&quot;);
      Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + &quot;_ViewBinding&quot;);
      //noinspection unchecked
      bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);
      if (debug) Log.d(TAG, &quot;HIT: Loaded binding class and constructor.&quot;);

    // 将 Activity 和 Activity_ViewBinding 建立一一关系，方便以后直接取出 Constructor
    BINDINGS.put(cls, bindingCtor);
    return bindingCtor;
  }
</code></pre><p>总而言之，就做了一件事：通过反射来触发 XxxActivity_ViewBinding 的构造器，然后构造器就完成了 findViewById setOnClickListener</p>
<pre><code>public class AdActivity_ViewBinding&lt;T extends AdActivity&gt; implements Unbinder {
  protected T target;

  private View view2131230880;

  private View view2131231171;

  @UiThread
  public AdActivity_ViewBinding(final T target, View source) {
    this.target = target;

    View view;
    view = Utils.findRequiredView(source, R.id.iv_ad, &quot;field &apos;mIvAd&apos; and method &apos;onViewClicked&apos;&quot;);
    target.mIvAd = Utils.castView(view, R.id.iv_ad, &quot;field &apos;mIvAd&apos;&quot;, ImageView.class);
    view2131230880 = view;
    view.setOnClickListener(new DebouncingOnClickListener() {
      @Override
      public void doClick(View p0) {
        target.onViewClicked(p0);
      }
    });
    view = Utils.findRequiredView(source, R.id.tv_skip, &quot;field &apos;mTvSkip&apos; and method &apos;onViewClicked&apos;&quot;);
    target.mTvSkip = Utils.castView(view, R.id.tv_skip, &quot;field &apos;mTvSkip&apos;&quot;, TextView.class);
    view2131231171 = view;
    view.setOnClickListener(new DebouncingOnClickListener() {
      @Override
      public void doClick(View p0) {
        target.onViewClicked(p0);
      }
    });
  }

  @Override
  @CallSuper
  public void unbind() {
    T target = this.target;
    if (target == null) throw new IllegalStateException(&quot;Bindings already cleared.&quot;);

    target.mIvAd = null;
    target.mTvSkip = null;

    view2131230880.setOnClickListener(null);
    view2131230880 = null;
    view2131231171.setOnClickListener(null);
    view2131231171 = null;

    this.target = null;
  }
}
</code></pre><h1 id="编译时期-APT-三件套"><a href="#编译时期-APT-三件套" class="headerlink" title="编译时期 APT 三件套"></a>编译时期 APT 三件套</h1><ul>
<li>注解处理器 APT （ButterKnifeProcessor） <ul>
<li>process<ul>
<li>步骤一：解析 ButterKnife 注解</li>
<li>步骤二：根据解析结果，使用 JavaPoet 生成 Java 文件</li>
</ul>
</li>
</ul>
</li>
<li>注册注解处理器 AutoService<ul>
<li>告诉编译器 ButterKnifeProcessor 信息，在编译时直接</li>
</ul>
</li>
<li><p>代码生成工具 JavaPoet （诗人）</p>
<p>  @Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) {</p>
<pre><code>      // 获取并收集注解信息
      Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);

      for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) {
        TypeElement typeElement = entry.getKey();
        BindingSet binding = entry.getValue();

          // JavaPoet 生成 Java 文件
        JavaFile javaFile = binding.brewJava(sdk, debuggable, useLegacyTypes);
        try {
          javaFile.writeTo(filer);
        } catch (IOException e) {
          error(typeElement, &quot;Unable to write binding for type %s: %s&quot;, typeElement, e.getMessage());
        }
      }

  return false;
}
</code></pre></li>
</ul>
<p>首先了解 RoundEnvironment </p>
<pre><code>package javax.annotation.processing;

import java.lang.annotation.Annotation;
import java.util.Set;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;

public interface RoundEnvironment {
    boolean processingOver();

    boolean errorRaised();

    Set&lt;? extends Element&gt; getRootElements();

    Set&lt;? extends Element&gt; getElementsAnnotatedWith(TypeElement var1);

    // 查找到 拥有该注解的元素 可能是 Variable 可能是 Method
    Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; var1);
}
</code></pre><p>就是说：</p>
<pre><code>private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) {
Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;();
Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;();

// Process each @BindAnim element.
for (Element element : env.getElementsAnnotatedWith(BindAnim.class)) {
  if (!SuperficialValidation.validateElement(element)) continue;
  try {
    parseResourceAnimation(element, builderMap, erasedTargetNames);
  } catch (Exception e) {
    logParsingError(element, BindAnim.class, e);
  }
}

// Process each @BindArray element.
for (Element element : env.getElementsAnnotatedWith(BindArray.class)) {
  if (!SuperficialValidation.validateElement(element)) continue;
  try {
    parseResourceArray(element, builderMap, erasedTargetNames);
  } catch (Exception e) {
    logParsingError(element, BindArray.class, e);
  }
}

// Process each @BindBitmap element.
for (Element element : env.getElementsAnnotatedWith(BindBitmap.class)) {
  if (!SuperficialValidation.validateElement(element)) continue;
  try {
    parseResourceBitmap(element, builderMap, erasedTargetNames);
  } catch (Exception e) {
    logParsingError(element, BindBitmap.class, e);
  }
}

// Process each @BindBool element.
for (Element element : env.getElementsAnnotatedWith(BindBool.class)) {
  if (!SuperficialValidation.validateElement(element)) continue;
  try {
    parseResourceBool(element, builderMap, erasedTargetNames);
  } catch (Exception e) {
    logParsingError(element, BindBool.class, e);
  }
}

// Process each @BindColor element.
for (Element element : env.getElementsAnnotatedWith(BindColor.class)) {
  if (!SuperficialValidation.validateElement(element)) continue;
  try {
    parseResourceColor(element, builderMap, erasedTargetNames);
  } catch (Exception e) {
    logParsingError(element, BindColor.class, e);
  }
}

// Process each @BindDimen element.
for (Element element : env.getElementsAnnotatedWith(BindDimen.class)) {
  if (!SuperficialValidation.validateElement(element)) continue;
  try {
    parseResourceDimen(element, builderMap, erasedTargetNames);
  } catch (Exception e) {
    logParsingError(element, BindDimen.class, e);
  }
}

// Process each @BindDrawable element.
for (Element element : env.getElementsAnnotatedWith(BindDrawable.class)) {
  if (!SuperficialValidation.validateElement(element)) continue;
  try {
    parseResourceDrawable(element, builderMap, erasedTargetNames);
  } catch (Exception e) {
    logParsingError(element, BindDrawable.class, e);
  }
}

// Process each @BindFloat element.
for (Element element : env.getElementsAnnotatedWith(BindFloat.class)) {
  if (!SuperficialValidation.validateElement(element)) continue;
  try {
    parseResourceFloat(element, builderMap, erasedTargetNames);
  } catch (Exception e) {
    logParsingError(element, BindFloat.class, e);
  }
}

// Process each @BindFont element.
for (Element element : env.getElementsAnnotatedWith(BindFont.class)) {
  if (!SuperficialValidation.validateElement(element)) continue;
  try {
    parseResourceFont(element, builderMap, erasedTargetNames);
  } catch (Exception e) {
    logParsingError(element, BindFont.class, e);
  }
}

// Process each @BindInt element.
for (Element element : env.getElementsAnnotatedWith(BindInt.class)) {
  if (!SuperficialValidation.validateElement(element)) continue;
  try {
    parseResourceInt(element, builderMap, erasedTargetNames);
  } catch (Exception e) {
    logParsingError(element, BindInt.class, e);
  }
}

// Process each @BindString element.
for (Element element : env.getElementsAnnotatedWith(BindString.class)) {
  if (!SuperficialValidation.validateElement(element)) continue;
  try {
    parseResourceString(element, builderMap, erasedTargetNames);
  } catch (Exception e) {
    logParsingError(element, BindString.class, e);
  }
}

// Process each @BindView element.
for (Element element : env.getElementsAnnotatedWith(BindView.class)) {
  // we don&apos;t SuperficialValidation.validateElement(element)
  // so that an unresolved View type can be generated by later processing rounds
  try {
    parseBindView(element, builderMap, erasedTargetNames);
  } catch (Exception e) {
    logParsingError(element, BindView.class, e);
  }
}

// Process each @BindViews element.
for (Element element : env.getElementsAnnotatedWith(BindViews.class)) {
  // we don&apos;t SuperficialValidation.validateElement(element)
  // so that an unresolved View type can be generated by later processing rounds
  try {
    parseBindViews(element, builderMap, erasedTargetNames);
  } catch (Exception e) {
    logParsingError(element, BindViews.class, e);
  }
}

// Process each annotation that corresponds to a listener.
for (Class&lt;? extends Annotation&gt; listener : LISTENERS) {
  findAndParseListener(env, listener, builderMap, erasedTargetNames);
}

// Associate superclass binders with their subclass binders. This is a queue-based tree walk
// which starts at the roots (superclasses) and walks to the leafs (subclasses).
Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =
    new ArrayDeque&lt;&gt;(builderMap.entrySet());
Map&lt;TypeElement, BindingSet&gt; bindingMap = new LinkedHashMap&lt;&gt;();
while (!entries.isEmpty()) {
  Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst();

  TypeElement type = entry.getKey();
  BindingSet.Builder builder = entry.getValue();

  TypeElement parentType = findParentType(type, erasedTargetNames);
  if (parentType == null) {
    bindingMap.put(type, builder.build());
  } else {
    BindingSet parentBinding = bindingMap.get(parentType);
    if (parentBinding != null) {
      builder.setParent(parentBinding);
      bindingMap.put(type, builder.build());
    } else {
      // Has a superclass binding but we haven&apos;t built it yet. Re-enqueue for later.
      entries.addLast(entry);
    }
  }
}

return bindingMap;
</code></pre><p>  }</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xhdlmy.github.io/2018/10/22/幸福课/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee&Da">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/kuiba_dacang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XL'Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/22/幸福课/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-22T15:40:47+08:00">
                2018-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果你常常觉得不开心，也许是因为你想事情的四位方式出现了问题。</p>
<p>非黑即白：</p>
<p>具有两极化思维模式的人，看问题容易过于极端。对于他们来说，只要自己做不到百分百的完美，那就是一个完全你的失败者。如果伴侣有一次没有照顾到自己的需求，那对方就是“根本不爱自己”。</p>
<p>自动过滤积极面：</p>
<p>有这种思维模式的人，在各种事件、场合中，只关注那些负面的部分，过滤积极的一面。比如，在一次演讲过程汇总，完全忽略了热烈的掌声，只注意到自己在某个地方说错了词。<br>这并不是说他们不承认好事的存在，而是尽管知道有些部分是正面的，情绪仍然只能沉浸于不好的部分中。</p>
<p>过度概化：</p>
<p>这种思维模式的人，会基于自己某一次或几次的负面经验，得出非常泛化的结论，以偏概全。</p>
<p>“应该”构想</p>
<p>用“应该…”和“必须…”来激励自己和要求他人，常常容易适得其反。<br>当他们没有达到自己的“应该”时，他们会讨厌自己，感到羞耻和内疚。<br>而当他人没有达到他们的这种“应该”构想时，他们也会感到痛苦和愤愤不平。</p>
<p>情绪化推理</p>
<p>有情绪化推理就是以非理性的规律来认识世界。<br>比如，一个感觉自己不受欢迎，就开始逃避人群，事实上别人并没有表现出不友好的迹象。</p>
<p><strong>那么该如何做出改变的呢？</strong></p>
<p>记录场景：</p>
<p>上班过程中，如果同事在闲聊，我就会感到焦虑；我不讨厌他们，可能只是在学习过程中，觉得无法集中注意力。</p>
<p>但是如果他们不说话，我也会总觉得等下他们会交流，就会静不下心来。</p>
<p>但是如果他们不说话，我貌似也无法静下心来。</p>
<p>为什么我无法静下心来？</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xhdlmy.github.io/2018/10/18/2.3 注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee&Da">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/kuiba_dacang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XL'Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/18/2.3 注解/" itemprop="url">注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-18T14:05:18+08:00">
                2018-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="注解-Butterknife框架原理"><a href="#注解-Butterknife框架原理" class="headerlink" title="注解 Butterknife框架原理"></a>注解 Butterknife框架原理</h1><p><a href="https://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener">Java注解</a></p>
<p>定义：JDK1.5 开始加入源码的特殊语法元数据，注解就是用来描述源码（接口、类、方法、变量、参数等）的。</p>
<p>可以理解为标签，对于代码的直接逻辑并没有直接影响。</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>格式： @interface</p>
<pre><code>@Retention(CLASS) 
@Target(FIELD)
public @interface BindView {
  /** View ID to which the field will be bound. */
  @IdRes int value();
}

注意属性的格式： 要加上一个空括号，后面还可以跟上默认值 default 
如果属性只有一个名为 value 的属性，那么可以在使用的时候省略&quot;=&quot;,比如 @BindView(R.id.tv_back)
如果属性为空，那么使用的时候就可以省略后面的()
</code></pre><p>自定义一个注解，一定要用元注解来描述该注解的保留期、作用域等：</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>理解重要的两个：一个保留期、一个作用域</p>
<p>@Retention(RetentionPolicy.RUNTIME) </p>
<ul>
<li>取值 RetentionPolicy.RUNTIME 表示在运行阶段任然有效，例如 @Test</li>
<li>取值 RetentionPolicy.CLASS 表示在字节码阶段，例如 ButterKnife 就是在字节码阶段来解释这个注解的，生成 _ViewBinding</li>
</ul>
<p>@Target(ElementType.TYPE) 代表注解使用的范围</p>
<h2 id="注解的提取"><a href="#注解的提取" class="headerlink" title="注解的提取"></a>注解的提取</h2><p><strong>通过反射提取注解</strong></p>
<p>通过 Class 对象的 isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 方法判断它是否应用了某个注解</p>
<p>通过 Class 对象的 getAnnotation(Class annotationClass) or getAnnotations() 方法来获取 Annotation </p>
<p>得到注解类的对象后，可以调用注解的属性了！</p>
<ul>
<li><p>获取标识在类上的注解： @interface TestAnnotation</p>
<p>  boolean has = Test.class.isAnnotationPresent(TestAnnotation.class);<br>  if(has){</p>
<pre><code>TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class);
</code></pre><p>  }</p>
</li>
<li><p>获取标识在成员变量上的注解： @interface Check</p>
<p>  Field age = Test.class.getDeclaredField(“age”);<br>  age.setAccessible(true);<br>  //获取一个成员变量上的注解<br>  Check check = age.getAnnotation(Check.class);</p>
</li>
<li><p>获取标识在方法上的注解： @Perform</p>
<p>  Method testMethod = Test.class.getDeclaredMethod(“testMethod”);<br>  if ( testMethod != null ) {</p>
<pre><code>// 获取方法中的注解
Annotation ans = testMethod.getAnnotation(Perform.class);
</code></pre><p>  }</p>
</li>
</ul>
<p>栗子：</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME) // 必须是在运行期有效，不然 @Test 的时候，ss 获取注解得到的是 null
@Target(ElementType.FIELD)
public @interface BindView {
    int value() default 1;
}

public class AnnotationTest {

    @BindView()
    String s = &quot;&quot;;

    @Test
    public void main(){
        try {
            Field ss = AnnotationTest.class.getDeclaredField(&quot;s&quot;);
            ss.setAccessible(true);
            boolean annotationPresent = ss.isAnnotationPresent(BindView.class);
            if(annotationPresent){
                BindView annotation = ss.getAnnotation(BindView.class);
                System.out.println(&quot;value:&quot; + annotation.value());
            }
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
    }

}
</code></pre><p>总而言之，要获取注解必须是 Class 对象才可通过 getAnnotation() 得到。</p>
<h2 id="注解的使用场景"><a href="#注解的使用场景" class="headerlink" title="注解的使用场景"></a>注解的使用场景</h2><p>注解是一系列元数据，它提供数据用来解释程序代码，但是注解并非是所解释的代码本身的一部分。注解对于代码的运行效果没有直接影响。</p>
<p>注解有许多用处，主要如下：</p>
<ul>
<li>提供信息给编译器： 编译器可以利用注解来探测错误和警告信息</li>
<li>编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。 APT编程 注解处理器（用来生成）</li>
<li>运行时的处理： 某些注解可以在程序运行的时候接受代码的提取 </li>
</ul>
<p>当开发者使用了Annotation 修饰了类、方法、Field 等成员之后，这些 Annotation 不会自己生效，必须由开发者提供相应的代码来提取并处理 Annotation 信息。这些处理提取和处理 Annotation 的代码统称为 APT（Annotation Processing Tool)。  </p>
<p>如果是 APT 技术，那么注解的保留期元注解为 @Retention(RetentionPolicy.CLASS) 即可，在编译时，生成新的代码。注解的提取需要借助于 Java 的反射技术，反射比较慢，所以注解使用时也需要谨慎计较时间成本，APT 技术是在编译阶段耗费时间，但运行阶段效率没有影响的。</p>
<p><strong>注解有什么用？给谁用？给编译器或者 APT 用的。</strong></p>
<h1 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a>ButterKnife</h1><p><strong>被元注解 @Retention(RetentionPolicy.CLASS) 标记的注解，在编译时由 APT（ButterKnife框架自定义的 Processor）来解析该注解，并生成相关代码。</strong></p>
<p><strong>在javac进行编译时，ButterKnifeProcessor 的 process() 方法被调用</strong>，生成相关的 _ViewBinder 类，用于将 View 或者 Listener 进行绑定。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xhdlmy.github.io/2018/10/17/2.2 泛型 Gson反序列化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee&Da">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/kuiba_dacang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XL'Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/17/2.2 泛型 Gson反序列化/" itemprop="url">JDK1.5 泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-17T10:41:49+08:00">
                2018-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="泛型-泛型擦除"><a href="#泛型-泛型擦除" class="headerlink" title="泛型 泛型擦除"></a>泛型 泛型擦除</h1><p>概念：参数化类型</p>
<blockquote>
<p>泛型的就是参数化类型。也就是说在泛型使用过程中，操作的数据类型被指定为一个形式参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。泛型也是如此，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式，然后在使用/调用时传入具体的类型（类型实参）。</p>
</blockquote>
<pre><code>定义泛型方法： public &lt;T extends Human&gt; T wrap(T t) 形式参数， 
调用时传入实际参数：Human human 或者 Human 的子类，例如 Solder solder（军人）
</code></pre><p>JDK1.5 之所以要专门引入泛型，就是为了一个安全、方便。</p>
<ul>
<li>安全：运行期间不会出现类型转换错误，因为在编译期就可以判断，泛型是只有在编译期有效。</li>
<li>方便：编译期避免了大量的强制类型转换。</li>
</ul>
<p>以上是直观的了解泛型，但深入了解泛型就必须明白什么是泛型擦除，泛型引入的原理。</p>
<p><a href="https://blog.csdn.net/briblue/article/details/76736356" target="_blank" rel="noopener">泛型擦除</a> </p>
<p>泛型只是在编译期间起作用，在运行时是不存在泛型的，也就是说字节码与非泛型写法是一致的，也就是为什么泛型可以向下兼容的原因。</p>
<p>也就是说，泛型只是提供了不一样的编程体验，T 本身是参数化类型，可看作 T extends Object 一样，跟 Object 一样，可以代替任何数据类型。</p>
<blockquote>
<p>为了解决类型之间的继承关系，引入了通配符的概念，除了用 <t> 表示泛型外，还有 &lt;?&gt; 这种形式。？ 被称为通配符。 ? 不加限制就可以实实在在地理解为 Object 了。</t></p>
</blockquote>
<pre><code>public class Cache&lt;T&gt; {

    T value; 

    public Cache(T value){ this.value = value; }

    public T getValue() { return value; } 

    public void setValue(T value) { this.value = value; } 
}
</code></pre><p>将 T 换成 Object 没有任何问题，我们可以在运行时通过反射验证：</p>
<pre><code>Cache&lt;String&gt; cache = new Cache&lt;String&gt;(&quot;balabala&quot;);
Class cls = cache.getClass();
System.out.println(&quot;cache class is:&quot;+cls.getName());
Field[] fs = eclz.getDeclaredFields();
for ( Field f:fs) { 
    System.out.println(Field Type: &quot; + f.getType().getName()); 
}
</code></pre><p>打印结果是 <figure class="highlight plain"><figcaption><span>Type: java.lang.Object```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将 Cache 换成带限制条件的，</span><br><span class="line"></span><br><span class="line">	public class Cache&lt;T extends String&gt; &#123;</span><br><span class="line"> </span><br><span class="line">		T value; </span><br><span class="line"></span><br><span class="line">		public Cache(T value)&#123; this.value = value; &#125;</span><br><span class="line"></span><br><span class="line">		public T getValue() &#123; return value; &#125; </span><br><span class="line"></span><br><span class="line">		public void setValue(T value) &#123; this.value = value; &#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">那么打印的结果就是 ```Field Type: java.lang.String</span><br></pre></td></tr></table></figure></p>
<p>泛型在编译成 class 后，代码中的参数类型会全部改成 泛型上限的数据类型。</p>
<p><strong>字节码只会保留原始类型（Cache），原始类型（raw type）就是擦除去了泛型信息后的类型。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。</strong></p>
<h2 id="那么泛型是如何实现的呢？"><a href="#那么泛型是如何实现的呢？" class="headerlink" title="那么泛型是如何实现的呢？"></a><strong>那么泛型是如何实现的呢？</strong></h2><p><a href="https://blog.csdn.net/xiangwanpeng/article/details/77896340" target="_blank" rel="noopener">泛型的内部原理</a></p>
<p>1、先检查，再编译</p>
<p>既然说类型变量会在编译的时候擦除掉，那为什么我们往 <figure class="highlight plain"><figcaption><span>arrayList </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">答曰：java编译器是通过先检查代码中泛型的类型，然后再进行类型擦除，在进行编译的。</span><br><span class="line"></span><br><span class="line">2、自动类型转换</span><br><span class="line"></span><br><span class="line">因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？看下ArrayList&lt;E&gt; 的 get() 方法：</span><br><span class="line"></span><br><span class="line">	E elementData(int var1) &#123;</span><br><span class="line">        return this.elementData[var1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E get(int var1) &#123;</span><br><span class="line">        this.rangeCheck(var1);</span><br><span class="line">        return this.elementData(var1);</span><br><span class="line">    &#125;</span><br><span class="line">                                                            </span><br><span class="line">可以看到在 return 时会进行强制类型转换。</span><br><span class="line"></span><br><span class="line">## 如何在运行时得到编译期泛型的信息？</span><br><span class="line"></span><br><span class="line">**如果要在运行时得到编译期泛型的信息，如何做到？**</span><br><span class="line"></span><br><span class="line">答： Java 为开发者提供了 Type 接口，可以得到所需的泛型信息。</span><br></pre></td></tr></table></figure></p>
<pre><code>- Type 描述一切类型
    - Class    类 (原始类型 raw type)
    - ParameterizedType （参数化类型）Map&lt;Key, Value&gt; List&lt;? extends Number&gt;
    - GenericArrayType （泛型数组类型） List&lt;String&gt;[] 是， String[] strings 否
    - TypeVariable （泛型变量 K V）
    - WildcardType (通配符) ? extends Number
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">也就是说，如果泛型信息在运行中擦除了，但是实现了 ParameterizedType 接口，会通过 getActualTypeArguments() 存起来。</span><br><span class="line"></span><br><span class="line"># Gson</span><br><span class="line"></span><br><span class="line">## Gson 关于泛型的处理</span><br><span class="line"></span><br><span class="line">&gt; Gson 是 Google 发布的 lib，主要是为了方便将 Java 对象与 json 格式数据相互转化。Java对象序列化至json格式数据，json格式数据反序列化至Java对象。</span><br><span class="line"></span><br><span class="line">1. JDK 1.5 新增 Type 的子接口 ParameterizedType</span><br></pre></td></tr></table></figure>
<pre><code>    public interface ParameterizedType extends Type {

        Type[] getActualTypeArguments(); // 该方法就是获取参数化类型

        Type getRawType();

        Type getOwnerType();
    }

    Impl 实现方法可能

    public static ParameterizedType type(final Class raw, final Type... args){

        return new ParameterizedType() {

            @Override
            public Type[] getActualTypeArguments() {
                return args;
            }

            @Override
            public Type getRawType() {
                return raw;
            }

            // 关注不多 Map.Entry&lt;K, V&gt;
            @Override
            public Type getOwnerType() {
                return null;
            }
        };
    }


```
</code></pre><p><strong>即使在运行过程中，泛型信息被擦除了，但也将泛型信息存入了 getActualTypeArguments() 方法的实现中。</strong></p>
<ol start="2">
<li>Gson 包提供 TypeToken 来获取泛型信息</li>
</ol>
<p>例如：BaseResp 格式统一有 error，不同的在于 T data</p>
<pre><code>public class BaseResp&lt;T&gt; implements Serializable {
    public boolean error;
    public T results;
}
</code></pre><p>那么可以通过 Gson 反序列化这么解析得到 T 的对象：</p>
<pre><code>BaseResp&lt;T&gt; resp = sGson.fromJson(json, new TypeToken&lt;BaseResp&lt;T&gt;&gt;(){}.getType()); // 匿名内部类
</code></pre><p>那么 </p>
<pre><code>protected TypeToken() {
    this.type = getSuperclassTypeParameter(getClass());
    this.rawType = (Class&lt;? super T&gt;) $Gson$Types.getRawType(type);
    this.hashCode = type.hashCode();
  }

static Type getSuperclassTypeParameter(Class&lt;?&gt; subclass) {
    // TypeToken&lt;BaseResp&lt;T&gt;&gt;
    Type superclass = subclass.getGenericSuperclass();
    if (superclass instanceof Class) {
      throw new RuntimeException(&quot;Missing type parameter.&quot;);
    }
    ParameterizedType parameterized = (ParameterizedType) superclass;
    return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]); // BaseResp&lt;T&gt;
  }
</code></pre><p>$Gson$Types </p>
<pre><code>public static Type canonicalize(Type type) {
    if(type instanceof Class) {
        Class&lt;?&gt; c = (Class)type;
        return (Type)(c.isArray()?new $Gson$Types.GenericArrayTypeImpl(canonicalize(c.getComponentType())):c);
    } else if(type instanceof ParameterizedType) {
        ParameterizedType p = (ParameterizedType)type;
        return new $Gson$Types.ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments());
    } else if(type instanceof GenericArrayType) {
        GenericArrayType g = (GenericArrayType)type;
        return new $Gson$Types.GenericArrayTypeImpl(g.getGenericComponentType());
    } else if(type instanceof WildcardType) {
        WildcardType w = (WildcardType)type;
        return new $Gson$Types.WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());
    } else {
        return type;
    }
}
</code></pre><p>可以看出 type 为 BaseResp<t>，rawType 为 BaseResp，其中 $Gson$Types 包含了一个内部类 ParameterizedType。</t></p>
<p>在网络请求过程中，例如创建了 RxRequest&lt;List<meizi>&gt; request，那么可以通过 request 得到传入的 List<meizi> 类型信息，那么就可以在反序列化中 new TypeToken&lt;BaseResp&lt;List<meizi>&gt;&gt;(){}.getType()； 然后 Gson 就明白需要将 json 格式数据转为 List<meizi> 集合对象。</meizi></meizi></meizi></meizi></p>
<h2 id="Gson-的工作原理"><a href="#Gson-的工作原理" class="headerlink" title="Gson 的工作原理"></a>Gson 的工作原理</h2><ul>
<li>Gson fromJson() 对应的底层方法是 TypeAdapter read(JsonReader) </li>
<li>Gson toJson() 对应的底层方法是 TypeAdapter write(JsonReader, T) </li>
</ul>
<p>fromJson 的重载方法：</p>
<pre><code>public &lt;T&gt; T fromJson(JsonReader reader, Type typeOfT)
    ...
    TypeToken&lt;T&gt; typeToken = (TypeToken&lt;T&gt;) TypeToken.get(typeOfT);
    TypeAdapter&lt;T&gt; typeAdapter = getAdapter(typeToken);
    T object = typeAdapter.read(reader);
    return object;
    ...
}
</code></pre><p>TypeAdapter<t> 是序列化/反序列化 的地方，例如 已知 T：</t></p>
<pre><code>public static final class Adapter&lt;T&gt; extends TypeAdapter&lt;T&gt; {
private final ObjectConstructor&lt;T&gt; constructor;
private final Map&lt;String, BoundField&gt; boundFields;

Adapter(ObjectConstructor&lt;T&gt; constructor, Map&lt;String, BoundField&gt; boundFields) {
  this.constructor = constructor;
  this.boundFields = boundFields;
}

@Override public T read(JsonReader in) throws IOException {
  if (in.peek() == JsonToken.NULL) {
    in.nextNull();
    return null;
  }

  // 这里就是通过反射来创建对象的。
  T instance = constructor.construct();

  try {
    in.beginObject();
    while (in.hasNext()) {
      String name = in.nextName();
      BoundField field = boundFields.get(name);
      if (field == null || !field.deserialized) {
        in.skipValue();
      } else {
        field.read(in, instance);
      }
    }
  } catch (IllegalStateException e) {
    throw new JsonSyntaxException(e);
  } catch (IllegalAccessException e) {
    throw new AssertionError(e);
  }
  in.endObject();
  return instance;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xhdlmy.github.io/2018/10/08/2.1 反射/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee&Da">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/kuiba_dacang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XL'Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/08/2.1 反射/" itemprop="url">Java Reflection （反射机制）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-08T15:04:25+08:00">
                2018-10-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从-Java-的运行原理理解反射机制"><a href="#从-Java-的运行原理理解反射机制" class="headerlink" title="从 Java 的运行原理理解反射机制"></a>从 Java 的运行原理理解反射机制</h1><p>概念：Java的反射概念是在运行状态中能动态加载、感知、使用编译期间的任何类；即可以加载在运行时才得知名称的Class对象，在内存中构造该类对象并获取其属性和方法。<br>问题：</p>
<ul>
<li><ol>
<li>在编译完成后生成 class 字节码文件，那么 Java 程序是如何运行的？</li>
</ol>
</li>
<li><ol start="2">
<li>为什么需要反射机制？</li>
</ol>
</li>
<li><ol start="3">
<li>反射机制如何实现？（Class Construction Field Method）</li>
</ol>
</li>
</ul>
<p><strong>理解 Java 语言</strong></p>
<blockquote>
<p>高级编程语言代码要转变成计算机所能执行的机器语言，有两种方式：</p>
<ul>
<li>编译：编译程序功能就是将高级编程语言翻译成与之等价的目标程序，可在特定的机器上直接执行。（如：Java将 .java 文件编译成 .class文件，可在 JVM 平台上运行）<ul>
<li>优点：运行效率高，平台直接执行目标代码</li>
<li>缺点：专一性，编译后程序无法跨平台（Java通过开发与不同平台适配的 JVM 中间层来完成适配，从而实现跨平台）</li>
</ul>
</li>
<li>解释：在运行程序时直接执行源程序或者源程序的中间代码，由特定的解释器来执行代码，解释是翻译一句执行一句。<ul>
<li>优点：跨平台容易</li>
<li>缺点：效率较低，解释器解释过程非常耗时，不能脱离解释器独立运行（不同的系统平台也需要开发不同的解释器）</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>编译型语言：C C++ Object-C</p>
</blockquote>
<blockquote>
<p>解释型语言：Python JavaScript</p>
</blockquote>
<p>Java语言是编译和解释的结合体，所以效率高，也跨平台。</p>
<ul>
<li>首先将Java源代码编译成与平台无关的class字节码文件(编译)</li>
<li>通过不同平台的JVM虚拟机来执行字节码文件(解释)</li>
</ul>
<blockquote>
<p>静态语言 vs 动态语言</p>
<p>动态类型语言：类型的检查是在运行时来进行的，源代码是否合法只能在运行时才能判断。</p>
<p>静态类型语言：类型的检查是在编译时就可确定，也就是写程序时要声明变量的数据类型。</p>
<p>也有说动态语言：程序运行时，允许改变程序结构或者变量类型。</p>
</blockquote>
<h2 id="Java-程序的运行过程"><a href="#Java-程序的运行过程" class="headerlink" title="Java 程序的运行过程"></a>Java 程序的运行过程</h2><p>JDK：JRE + Java API + Tools<br>JRE：JVM + JAVA核心类库和支持文件 （所有 Java 程序都要在 JRE 环境下才能运行）<br>JVM：</p>
<p>Java开发：我们利用JDK（调用JAVA API）开发一个 JAVA 程序后，通过 javac 工具将编写的 .java 文件编译成 .class 字节码文件；这些字节码文件必须在 JRE 环境中运行（必须依赖 JAVA核心库），由 JVM 解释这些字节码成为系统平台本地代码后，映射到CPU指令集或OS的系统调用。</p>
<blockquote>
<p>比如当代码中需要做 IO 操作时，就是调用 java API 的过程。查看源码便知，IO 操作实际是依赖于底层操作系统的，例如在操作系统 A 中，实际删除文件调用的是本地方法(native method) remove()，而操作系统 B 中实际调用的是delete()。而 Java 程序员不关心底层实现，而是去调用 java API 中规定的统一方法 deleteFile()。当程序在系统 A 中运行时，java 虚拟机中的执行器会将 deleteFile() 解释为本地方法 remove()。这就是为什么 .class 字节码文件不能直接独立运行，必须靠 JVM 执行引擎来解释成本地代码后才能执行。</p>
</blockquote>
<p><img src="/img/JVM_theory.png" alt="JVM"></p>
<p>JVM 的执行引擎就是一个解释器，例如可以把部分 JAVA API 接口转换成具体的 native 本地系统平台的实现。</p>
<p><img src="/img/JVM.jpg" alt="JVM"></p>
<p>JVM 就是将”静”的代码”跑起来”的地方，程序运行就是在内存中执行程序指令。</p>
<p>一个Java程序的运行必然要开辟一块内存（堆 栈 方法区），用来跑 JVM 进程。<br>JVM中的线程分为两种：普通线程和守护线程（守护线程是 JVM 自己使用的线程，比如 GC 线程就是一个守护线程）。线程可以理解为程序执行的流程单元。</p>
<ul>
<li>堆：存储的全是对象本身，每个对象都包含一个与之对应的 class 的信息（class 的目的是为了得到操作指令，可以理解为获取对象的属性|方法）。<ul>
<li>堆区的对象被所有的线程共享。</li>
</ul>
</li>
<li>栈：每个线程包含一个栈区，只保存基础数据类型的对象，或者自定义对象的引用（猜测栈区追求效率，较小，不存放对象）。<ul>
<li>每个线程拥有一个方法调用栈区，用来记录、跟踪该线程运行汇总一系列的方法调用过程；每当线程调用一个方法的时候就会向方法栈压入一个新的栈帧，用来存储方法的参数，局部变量和运算过程中的临时数据。</li>
</ul>
</li>
<li>方法区：包含所有的 class 类信息、 static 变量，被所有线程共享。</li>
</ul>
<p>类加载过程（ClassLoader）：一个程序启动一个 JVM 进程，这个进程首先读取 .class 文件，将需要加载的类信息先加载进方法区中。</p>
<p>Java 程序的运行过程：</p>
<pre><code>AppMain.java

public class AppMain { //运行时, JVM 把 AppMain 的类信息都放入方法区

    public static void main(String[] args) { // static main 方法本身放入方法区
        Sample test1 = new Sample(&quot;测试1&quot;); // test1是引用，所以放到栈区里，Sample对象放到堆里面
        test1.printName();
    }

}

Sample.java

public class Sample { // 运行时, JVM 把 Sample 的类信息都放入方法区

    private String name; // new Sample实例后，name 引用放入栈区里，name String对象放入堆里

    public  Sample(String name) { // 构造方法类本身的信息统统放入方法区
        this .name = name;
    }

    public void printName() { // print 方法属于类本身信息放入方法区里。
        System.out.println(name);
    }

} 
</code></pre><p>Java 程序的运行过程：</p>
<ol>
<li>首先由类加载器将 APPMain 类信息加载进方法区中；</li>
<li>main函数主线程流程往下走：根据程序指令， Sample test1 = new Sample(“测试1”);  生成的对象之前，必须先获取 Sample 类的信息，那么类加载器先将 Sample 类信息加载进方法区中；</li>
<li>堆区开辟一块内存，存放 Sample 实例对象，这个 Sample 实例持有着指向方法区的 Sample 类的类型信息的引用。</li>
<li>位于 “=” 前的 test1 是一个在 main() 方法中定义的局部变量，因此，它被添加到了执行 main() 方法的主线程的方法调用栈中。 “=” 代表着 test1 持有着 Sample 对象的引用 。</li>
<li>接下来，JVM 将继续执行 test1.printName() 指令，根据局部变量 test1 持有的引用，定位到堆区中的 Sample 实例，再根据 Sample 实例持有的引用，定位到方法区中 Sample 类的类型信息，从而获得 printName() 方法的字节码，接着执行 printName() 方法包含的指令。</li>
</ol>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>Java 的类加载是在程序运行期间实现的，也就是说可以在运行时加载具体的类信息，提高了程序的灵活性：</p>
<ul>
<li>可以编写面向接口的应用程序，等到运行时再指定其实现的子类</li>
<li>可以自定义一个类加载器，让程序在运行时从网络或者其他地方（非程序本身的字节码文件）加载一个二进制流作为程序代码的一部分（这个是 Android 插件化、动态安装更新 Apk 的基础）</li>
</ul>
<blockquote>
<p>我们是否可以这样来架构软件框架。首先，我们的软件有一个配置文件，配置文件其实是一个文本，里面详细描述了，我们的软件核心部分运行起来后还需要从什么路径加载些什么类需要何时调用什么方法等。这样当我们需要加或减某些功能时，我们只需要简单地修改配置文本文件，然后删除或者添加相应的.class文件就可以了。<br>如果你足够敏感，你或许会发现，这种方式形成的配置文件几乎可以相当于一门脚本语言了。而且这个脚本的解释器也是我们自己写的，另外关键是它是开发的，你可以为它动态地加入一些新的类以增加它的功能。<br>不要以为这仅仅是一个设想，虽然要开发成一门完备的脚本语言确实比较麻烦。但是在一些网络端的大型项目中，通过配置文件 + ClassLoader + 反射机制结合形成的这种软件解耦和方式已经用得比较普遍了。</p>
</blockquote>
<p><a href="https://juejin.im/post/5b7e708b51882542b83d70c9" target="_blank" rel="noopener">Java反射机制</a></p>
<p><img src="/img/class_loading.png" alt="过程"></p>
<p>重点是明白第一个 ClassLoading 加载过程：</p>
<ol>
<li>通过全类名来获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构（静态代码-&gt;内存中数据结构）</li>
<li>如果是 new 对象，那么在堆区中生成一个代表这个类的对象，这个对象拥有一个“指针”，作为访问方法区该类型数据结构的访问入口</li>
</ol>
<p>JVM设计者把类加载阶段中的实现 “通过’类全名’来获取定义此类的二进制字节流” 这个动作的代码模块称为“类加载器”。</p>
<p><img src="/img/class_load_appoint.png" alt="类加载器"></p>
<p>双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。</p>
<p>保证了加载的同名类是同一个类！！！对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一性。也就是说，两个类来源于同一个 Class 文件，并且被同一个类加载器加载，这两个类才相等。</p>
<p><a href="https://blog.csdn.net/boyupeng/article/details/47951037" target="_blank" rel="noopener">JVM：类加载机制</a></p>
<h2 id="理解反射机制-反射机制是什么？Java-为什么需要反射机制？"><a href="#理解反射机制-反射机制是什么？Java-为什么需要反射机制？" class="headerlink" title="理解反射机制 反射机制是什么？Java 为什么需要反射机制？"></a>理解反射机制 反射机制是什么？Java 为什么需要反射机制？</h2><p><strong>仔细观察上面的流程图，需要加载的 Sample 类是在编译时就确定了的，但如果程序在运行时需要用到一个未被加载的类的对象，并调用其方法，那么是不是首先要加载这个类的信息到方法区中。</strong></p>
<p>概念：反射机制就是提供了让 Java 语言在程序运行时感知、获取程序集中的任何类的信息的能力。可以在运行时动态加载类、访问属性、调用方法。</p>
<p>扩展：静态语言 vs 动态语言</p>
<ul>
<li>动态类型语言：类型的检查是在运行时来进行的，源代码是否合法只能在运行时才能判断。</li>
<li>静态类型语言：类型的检查是在编译时就可确定，也就是写程序时要声明变量的数据类型。</li>
</ul>
<h3 id="反射机制的运用"><a href="#反射机制的运用" class="headerlink" title="反射机制的运用"></a>反射机制的运用</h3><ol>
<li><p>情景一：在运用 Struts2 框架中一般会在 struts.xml 配置化文件中配置 Action，</p>
 <action name="login" class="org.ScZyhSoft.test.action.SimpleLoginAction" method="execute"><br>     <result>/shop/shop-index.jsp</result><br>     <result name="error">login.jsp</result><br> </action>

</li>
</ol>
<p>那么配置文件与 Action 建立了一种映射关系，当 View 层发出请求时，请求会被StrutsPrepareAndExecuteFilter 拦截，然后 StrutsPrepareAndExecuteFilter 会去动态地创建 Action 实例。</p>
<p>比如我们请求 login.action，那么 StrutsPrepareAndExecuteFilter 就会去解析 struts.xml 文件，检索 action 中 name 为 login 的 Action，并根据 class 属性创建 SimpleLoginAction 实例，并用 invoke 方法来调用 execute 方法，这个过程离不开反射。</p>
<p><strong>反射最重要的就是开发各种通用框架</strong></p>
<ol start="2">
<li><p>情景二：在网络请求中，并不能在编译期间就得知请求完成时的 json 数据应该反序列化成那个具体的 XxxResp 类，不同的网络请求得到的是不同的 XxxResp 信息，那么就需要在运行时根据 Gson TypeToken 解析出的泛型类信息来动态地创建该类对象。</p>
</li>
<li><p>情景三：强大的 IDE 提示：当我们动态输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这个过程就用到反射来列出该类的属性、方法。</p>
</li>
</ol>
<p><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">深入解析Java反射1</a></p>
<h3 id="反射机制是如何实现的？"><a href="#反射机制是如何实现的？" class="headerlink" title="反射机制是如何实现的？"></a>反射机制是如何实现的？</h3><p>问：如何做到的？</p>
<p>答：Class 类，描述类型的类。要理解反射，就先要理解 Class 类。</p>
<p>万物皆对象，对象是一个类的实例，所以类本身是 java.lang.Class 类的实例对象，也就是说 Class 类是所有类（包括Java核心类、你自己所创建的类）的类，是类的类型描述，拥有获取不同类的结构信息，包括构造、属性、方法等。</p>
<p>看之前的栗子，普通对象都是可以直接 new 出来的。但是 Class 的对象是类，类是不能通过 new 来创建的，构造器是私有的，只能由 JVM 类加载器来创建。</p>
<ol>
<li><p>获得 Class 对象 （一切反射API的开始）</p>
<p> // 通过外界传入类名<br> Class.forName(String className);</p>
<p> // 类的 class 属性<br> Class cls = String.class;</p>
<p> // 对象的 getClass() 方法<br> Panda panda = new Panda(“欢欢”);<br> Class cls = panda.getClass();</p>
</li>
<li><p>判断对象是否为某类的实例</p>
<p> instanceof 关键字 （对比类名和类加载器是否为同一个，如果是，则返回 true）</p>
</li>
<li><p>创建实例</p>
<p> // 简便创建无参构造<br> Class cls = Student.class;<br> cls.newInstance();</p>
<p> // 通过 Class 对象获取 Constructor 对象<br> Class cls = Student.class;<br> Constructor constructor = cls.getConstructor(String.class, Integer.class);<br> constructor.newInstance(“lmy”, 26);</p>
<p> // 创建数组<br> Class&lt;?&gt; cls = Class.forName(“java.lang.String”);<br> Array.newInstance(cls, 24); // len 为 24</p>
</li>
<li><p>获取属性</p>
<p> getFiled()<br> getDeclaredField() (获取声明的，不包括父类继承的)</p>
</li>
<li><p>获取方法</p>
<p> // 这里也说明了方法的重载与参数有关<br> getMethod(String name, Class… parameterTypes) 方法名，参数类型<br> getMethods()<br> getDeclaredMethods()</p>
</li>
<li><p>调用方法 运行状态动态调用某个方法</p>
<p> // 将通过反射API的对象作为参数传入来调用该方法，完全跟普通情况反了过来。<br> public Object invoke(Object obj, Object… args)</p>
</li>
</ol>
<h1 id="Java-动态代理"><a href="#Java-动态代理" class="headerlink" title="Java 动态代理"></a>Java 动态代理</h1><pre><code>// 静态代理
    QingDaoBeerFactory qingDaoBeerFactory = new QingDaoBeerFactory();
    QingDaoBeerBar qingDaoBeerBar = new QingDaoBeerBar(qingDaoBeerFactory);
    qingDaoBeerBar.saleBeer();

    // 动态代理
    /**
     * 返回一个代理接口的实例对象(包名+$Proxy+id)，该接口的方法由 InvocationHandler 来代理执行
     * 由于 com.xhd.tv.queentv.dynamic_proxy.$Proxy0 继承了 Proxy 实现了 BeerFactory 接口，所以可以往上泛化成 BeerFactory 类型,
     * 如果强制转化成 QingDaoBeerBar，则会报错：
     * java.lang.ClassCastException: com.sun.proxy.$Proxy4 cannot be cast to com.xhd.tv.queentv.dynamic_proxy.QingDaoBeerBar
     */
    BeerFactory beerBar =
            (BeerFactory) Proxy.newProxyInstance(BeerFactory.class.getClassLoader(), // 通过这个类加载器来定义这个代理类对象
            new Class[]{BeerFactory.class}, // 需要实现的代理接口
            new InvocationHandler() { // 每一个生成的代理接口对象都有一个 InvocationHandler 与之交互（接口方法的调用处理程序）
                /*
                This method will be invoked on an invocation handler
                when a method is invoked on a proxy instance that it is associated with.
                 */
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    method.invoke(new QingDaoBeerFactory(), args);
                    method.invoke(new HarbinBeerFactory(), args);
                    return null;
                }
            });
    beerBar.saleBeer(); // 实际上是调用了 InvocationHandler 的 invoke 方法，传入真实对象和参数，来代理真实对象的该接口方法。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xhdlmy.github.io/2018/10/08/2.4 Dagger2使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee&Da">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/kuiba_dacang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XL'Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/08/2.4 Dagger2使用/" itemprop="url">2.Dagger 依赖注入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-08T09:35:16+08:00">
                2018-10-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="1-依赖：在-Class-L-中，有-Class-X-的实例，那么就称-Class-L-对-Class-X-有一个依赖。"><a href="#1-依赖：在-Class-L-中，有-Class-X-的实例，那么就称-Class-L-对-Class-X-有一个依赖。" class="headerlink" title="1.依赖：在 Class L 中，有 Class X 的实例，那么就称 Class L 对 Class X 有一个依赖。"></a>1.依赖：在 Class L 中，有 Class X 的实例，那么就称 Class L 对 Class X 有一个依赖。</h3><pre><code>public class Human {
    ...
    Father father;
    ...
    public Human() {
        father = new Father();
    }
}
</code></pre><p>那么如果 Father 的构造或者其他方法改变，那么 Human 也需要修改关于使用 Father 的代码。这样 Human 依赖 Father 不够独立（非耦合）。</p>
<h3 id="2-依赖注入：依赖外部对象时，不主动初始化该外部对象，而是通过外部传入该依赖对象的方式来依赖该对象，称为依赖注入。"><a href="#2-依赖注入：依赖外部对象时，不主动初始化该外部对象，而是通过外部传入该依赖对象的方式来依赖该对象，称为依赖注入。" class="headerlink" title="2.依赖注入：依赖外部对象时，不主动初始化该外部对象，而是通过外部传入该依赖对象的方式来依赖该对象，称为依赖注入。"></a>2.依赖注入：依赖外部对象时，不主动初始化该外部对象，而是通过外部传入该依赖对象的方式来依赖该对象，称为依赖注入。</h3><pre><code>public class Human {
    ...
    Father father;
    ...
    public Human(Father father) {
        this.father = father;
    }
}
</code></pre><p>上面代码中，我们将 Father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。像这种非自己主动初始化依赖(对象)，而通过外部来传入依赖（对象）的方式，我们就称为依赖注入。</p>
<p>依赖注入：目标就是解耦。</p>
<h3 id="3-Java中的依赖注入-（使用-Inject-注解）"><a href="#3-Java中的依赖注入-（使用-Inject-注解）" class="headerlink" title="3.Java中的依赖注入 （使用 @Inject 注解）"></a>3.Java中的依赖注入 （使用 @Inject 注解）</h3><p>依赖注入的实现有多重途径，在 Java 中使用注解是最常用的。通过在字段的声明前添加 @Inject 注解进行标记，来实现该依赖对象的自动注入。</p>
<pre><code>public class Human {
    ...
    @Inject Father father;
    ...
    public Human() {
    }
}
</code></pre><p>实质上，如果你只是写了一个 @Inject 注解，Father 并不会被自动注入。你还需要使用一个依赖注入框架，并进行简单的配置。</p>
<ul>
<li>Java 依赖注入框架有 Google Guice、Spring </li>
<li>Android 依赖注入框架有 RoboGuice、Dagger</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xhdlmy.github.io/2018/09/25/History 历史是一个圆/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee&Da">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/kuiba_dacang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XL'Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/25/History 历史是一个圆/" itemprop="url">历史是一个圆吗？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-25T14:52:06+08:00">
                2018-09-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/随笔/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="中国政治制度"><a href="#中国政治制度" class="headerlink" title="中国政治制度"></a>中国政治制度</h1><h1 id="三权分立的制度优越性，权力关进制度的牢笼？"><a href="#三权分立的制度优越性，权力关进制度的牢笼？" class="headerlink" title="三权分立的制度优越性，权力关进制度的牢笼？"></a>三权分立的制度优越性，权力关进制度的牢笼？</h1><p>美国国父其实是一个群像，包括了华盛顿、亚当斯、富兰克林、汉密尔顿、杰斐逊、麦迪逊和杰伊，抛开历史的琐碎，他们的心路历程使他们对人性中权力的欲望心生畏惧，同时也明白人心易被腐蚀和诱惑的道理，因此他们相信制度远比“民主”更值得信赖而历久弥新。</p>
<h2 id="三权分立"><a href="#三权分立" class="headerlink" title="三权分立"></a>三权分立</h2><blockquote>
<p>“权力导致腐败，绝对的权力导致绝对的腐败”</p>
</blockquote>
<p>那些美国建国的精英们将制衡机制与国会立法、总统行政、法院司法三权分立写进了美国宪法。</p>
<p>美国的政治体系其架构的理念之一————社会契约论。国家存在的唯一目的就是根据人民的意愿来服务人民，国家所行驶的政治权力都离不开这个根本。</p>
<p><strong>主权在民</strong> </p>
<p>社会契约：开始是没有政府这一个概念的，强者可以按照自己的意愿控制并随时向其他人发号施令。于是乎，人们达成一个共识，来建立一个国家，然后授予国家足够的权力以保护众人的身家福利。当政府滥权时，起而反之不仅是人民的权利而且更是责任。那美国独立战争起源到宪法的订立都收到这个思想的影响。</p>
<p>据史载，《独立宣言》的主要起草人、美国第三任总统托马斯•杰佛逊和“宪法之父”、美国第四任总统詹姆斯•曼迪逊都深受社会契约论之影响，这也就能理解为什么美国宪法的第一句，就是以这样的三个字开英文始：We the people(我们人民)。</p>
<p>1 立法机构 </p>
<p>美国国会：参议院 众议院 （想到了英国的两院制：上议院 下议院）</p>
<p>众议院：基于各州的人口来划分选区，如果一个州人口过于稀少，那么也保证每个州至少有一名代表。 众议院议员任期两年，服务于小选区的选民，那么议员要干的活很多。</p>
<p>参议院：每州均分2席（50个州也就是100名参议员）参议员任期为6年，天然的州代表，服务于全州选民，出身属性或者学历背景往往好于众议员。</p>
<p>众议院议员一般在结束代表生涯后重新回到自己的生活中，少数幸运儿成为参议院的辩手；参议院则是行政和司法分支的人才库。</p>
<p>2 行政机构</p>
<p>4 相互制约</p>
<p>立法机构被赋予了立法的权力，它可以如此制衡行政机构：</p>
<p>· 以三分之二多数否决总统的否决权</p>
<p>· 通过预算来确定给各行政部门多少经费</p>
<p>· 通过弹劾来让总统下台</p>
<p>· 总统与外国签立条约，但须得到参议院的批准</p>
<p>· 总统可以任命内阁成员，但须得到参议院的批准</p>
<p>立法机构可如此制衡司法机构：</p>
<p>· 设立下级法院</p>
<p>· 通过弹劾让法官离职</p>
<p>· 法官的任命须得到参议院的认准</p>
<p>行政机构被赋予了实施法律的权力，它可以如此制衡立法机构：</p>
<p>· 否决权</p>
<p>· 可以召开国会特别会议</p>
<p>· 可以推荐立法</p>
<p>· 可以向人民呼吁，以表达对立法事务的关注或担心</p>
<p>行政机构可以如此制衡司法机构：</p>
<p>· 总统任命最高法院及其他联邦法院的法官</p>
<p>司法机构被赋予解释法律的权力，它可以如此制衡行政机构：</p>
<p>· 法官一旦任命后，即为终身制，也就是再也不用受行政机构的控制</p>
<p>· 法庭可以通过司法审议（Judicial Review)来确定行政部门是否违宪</p>
<p>司法机构可以如此制衡立法机构：</p>
<p>· 法院可以裁决各类法案是否违宪</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xhdlmy.github.io/2018/09/21/1.4 OkHttp源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee&Da">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/kuiba_dacang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XL'Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/1.4 OkHttp源码解析/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T17:59:57+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#OkHttp源码解析</p>
<p><a href="http://www.jianshu.com/p/6ffde18fb034#" target="_blank" rel="noopener">他山之石</a></p>
<p>整个流程：</p>
<p><img src="img/okhttp.png" alt="icon"></p>
<p>OkHttp是直接对Socket进行封装。</p>
<p>OkHttp实现Http协议。</p>
<p>那么首要解决的问题就是如何构建Request请求？如何获取服务器返回的响应Response？</p>
<p>而后如何发送请求，如何接收响应？</p>
<p>在Request到Response的转换过程中，涉及到http协议的建立连接，连接复用，缓存处理以及cookie处理等问题。(拦截器)</p>
<p>##1. 请求与响应的封装</p>
<p>###Request</p>
<p>1、请求封装的组成</p>
<p>如果熟悉Http协议就会知道，请求报文由请求头和请求体组成，那么我们就应该对Http协议进行封装（封装就是将Http一些的内容：请求头、请求体等封装到一个类中）</p>
<pre><code>public final class Request {
  final HttpUrl url;
  final String method;
  final Headers headers;
  final RequestBody body;
  final Object tag;
  ...
}

tag是一个请求的标识，可以在后续的过程中终止或取消这个请求。

Headers类是一个工具类，统一管理请求和响应的头部信息，其内部结构就是一个nameAndValue的字符串数组保存头部信息，保存形式为一个键值紧跟一个value值， 熟悉Android中的ArrayMap数据结构的同学应该对这种实现方式比较了解。

public abstract class RequestBody {
  /** Returns the Content-Type header for this body. */
  public abstract MediaType contentType();
  /**
   * Returns the number of bytes that will be written to {@code out} in a call to {@link #writeTo},
   * or -1 if that count is unknown.
   */
  public long contentLength() throws IOException {
    return -1;
  }    
  /** Writes the content of this request to {@code out}. */
  public abstract void writeTo(BufferedSink sink) throws IOException;
  ...
}

contentType 就是封装了Content-Type，例如text/html

writeTo方法：指定请求体需要写入的内容
</code></pre><blockquote>
<p>Okio：这里的Sink和后面遇到的Source是属于Okio的内容，也就是square公司封装的一个IO框架，暂时可以将他们分别理解为OutputStream和InputStream。</p>
</blockquote>
<pre><code>request.requsetBody().writeTo(Okio.sink(socket.outputStream()))， 类似与这种形式，从而完成将请求体内容写入到socket中。
</code></pre><p>2、请求封装的构建过程</p>
<p>使用建造者模式，通过Builder设置不同参数。</p>
<pre><code>Request request = new Request.Builder().get().url(url).build();
</code></pre><p>###Response</p>
<p>Response的封装与之类似，但是获取响应必然与缓存有关，这里先省略与缓存相关的部分（将在第三篇文章中介绍）， 只是简单介绍一些响应的获取构建以及响应体的内容提取。</p>
<pre><code>public final class Response implements Closeable {
  final Request request;
  final int code;
  final String message;
  final Handshake handshake;
  final Headers headers;
  final ResponseBody body;

  Response(Builder builder) {
  ...
  }
}

public abstract class ResponseBody implements Closeable {
  /** Multiple calls to {@link #charStream()} must return the same instance. */
  private Reader reader;

  public abstract MediaType contentType();    
  /**
   * Returns the number of bytes in that will returned by {@link #bytes}, or {@link #byteStream}, or
   * -1 if unknown.
   */
  public abstract long contentLength();
  public abstract BufferedSource source();
...
}
</code></pre><blockquote>
<p>与Request类似，简历Socket连接的时候，肯定会有</p>
</blockquote>
<pre><code>response.body().source(Okio.source(socket.inputStream()))
</code></pre><p>ResponseBody responseBody = response.body();</p>
<pre><code>responseBody提供了byteStream();返回一个输入流
</code></pre><p>对于ResponseBody说明两个问题</p>
<p>一是每个ResponseBody的背后都是一个socket或者文件资源作为数据后备，因此在使用完以后需要关闭资源，不然会造成浪费。</p>
<p>二是，ResponseBody应该只能使用一次， 因为不能将响应完全缓存到内存中，因此需要我们通过byte()或者string一次性将响应体加载到内存使用，或者source()和byteStream()方法以流的方式使用，使用完成以后需要关闭，不能第二次使用。</p>
<p>除此以外我们还需要注意的是，网络通信都是字节流，那么就会涉及到字符编解码的问题，即charset问题， 这个问题这里不再介绍，Java的I/O库对此有处理，Okio同样也有处理，有兴趣的可以自行查看。</p>
<p>##2、请求过程的封装Call</p>
<p>它是对request的封装，也是对一次请求过程的封装，因为从call中我们可以获取响应，因此可以将其看做是一次请求过程的封装，期间请求的过程对于用户即使用okhttp的程序员来说是透明的。</p>
<p>下面看一下Call接口，</p>
<pre><code>public interface Call extends Cloneable {
  Request request();
  Response execute();同步请求    
  void enqueue(Callback responseCallback);    异步请求
  void cancel();    
  boolean isExecuted();
  boolean isCanceled();
  ...
}
</code></pre><p>真正的实现类：</p>
<pre><code>final class RealCall implements Call {
  final OkHttpClient client;
  final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;

  /** The application&apos;s original request unadulterated by redirects or auth headers. */
  final Request originalRequest;
  final boolean forWebSocket;

  // Guarded by this.
  private boolean executed;

  RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
    this.client = client;
    this.originalRequest = originalRequest;
    this.forWebSocket = forWebSocket;
    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
  }

  @Override public Request request() {
    return originalRequest;
  }

  //同步执行方法
  @Override public Response execute() throws IOException {
    synchronized (this) {
      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);
      executed = true;
    }
    captureCallStackTrace();
    try {
     //仅仅是标识该call对象已经开始执行
      client.dispatcher().executed(this);
      //真正地去执行网络请求
      Response result = getResponseWithInterceptorChain();
      if (result == null) throw new IOException(&quot;Canceled&quot;);
      return result;
    } finally {
      //标识该call对象的请求过程结束
      client.dispatcher().finished(this);
    }
  }

  ...

 //异步执行方法
  @Override public void enqueue(Callback responseCallback) {
    synchronized (this) {
      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);
      executed = true;
    }
    captureCallStackTrace();
    client.dispatcher().enqueue(new AsyncCall(responseCallback));
  }
  ...
</code></pre><p>即同同步方法网络请求是通过getResponseWithInterceptorChain方法获取的响应， 涉及到dispatcher的部分只是设置标志位而已（为了与异步执行统一处理）</p>
<pre><code>final class AsyncCall extends NamedRunnable {
  private final Callback responseCallback;

  AsyncCall(Callback responseCallback) {
    super(&quot;OkHttp %s&quot;, redactedUrl());
    this.responseCallback = responseCallback;
  }

  ...

  @Override protected void execute() {
    boolean signalledCallback = false;
    try {
      Response response = getResponseWithInterceptorChain();
      if (retryAndFollowUpInterceptor.isCanceled()) {
        signalledCallback = true;
        responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));
      } else {
        signalledCallback = true;
        responseCallback.onResponse(RealCall.this, response);
      }
    } catch (IOException e) {
      if (signalledCallback) {
        // Do not signal the callback twice!
        Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);
      } else {
        responseCallback.onFailure(RealCall.this, e);
      }
    } finally {
      client.dispatcher().finished(this);
    }
  }
}
</code></pre><p>同样异步执行也是将执行的getResponseWithInterceptorChain方法获取的网络请求。</p>
<p>Call接口的取消操作都交由retryAndFollowUpInterceptor来处理。</p>
<p>成功回调：</p>
<pre><code>responseCallback.onResponse(RealCall.this, response);
</code></pre><p>失败回调：</p>
<pre><code>responseCallback.onFailure(RealCall.this, e);
</code></pre><p>cancel回调：</p>
<pre><code>responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));
</code></pre><p>##3、异步请求：任务队列管理与调度</p>
<p><strong>OkHttp的任务管理和调度都是通过Dispatcher类来完成的!</strong></p>
<p>##4、Response getResponseWithInterceptorChain()核心</p>
<pre><code>private Response getResponseWithInterceptorChain() throws IOException {
  // Build a full stack of interceptors.
  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); 
  interceptors.addAll(client.interceptors());     // client.addInterceptor(Interceptor interceptor) 
  interceptors.add(retryAndFollowUpInterceptor);
  interceptors.add(new BridgeInterceptor(client.cookieJar()));
  interceptors.add(new CacheInterceptor(client.internalCache()));
  interceptors.add(new ConnectInterceptor(client));
  if (!retryAndFollowUpInterceptor.isForWebSocket()) {
    interceptors.addAll(client.networkInterceptors());
  }
  interceptors.add(new CallServerInterceptor(
      retryAndFollowUpInterceptor.isForWebSocket()));

  Interceptor.Chain chain = new RealInterceptorChain(
      interceptors, null, null, null, 0, originalRequest);
  return chain.proceed(originalRequest);
}
</code></pre><p>Interceptor 拦截器 拦截并修改 Request/Response 请求头或者响应头</p>
<pre><code>Response intercept(Interceptor.Chain chain)
</code></pre><p>Interceptor.Chain 真正将 Request 转化成 Response</p>
<pre><code>Response proceed(Request request)
</code></pre><p>一切从 getResponseWithInterceptorChain 方法开始：</p>
<pre><code>第一个 Interceptor.Chain chain = new ReaiInterceptorChain(index: 0, request: originalRequest);
返回的 Response 为 chain.proceed(originalRequest);
</code></pre><p>ReaiInterceptorChain 的 proceed 方法就是先 intercept 一级一级的拦截处理</p>
<pre><code>// Call the next interceptor in the chain.
RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
    connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
    writeTimeout);
Interceptor interceptor = interceptors.get(index);
Response response = interceptor.intercept(next);
</code></pre><p>不同的 Interceptor 的 intercept 方法不同：</p>
<pre><code>Response response = retryAndFollowUpInterceptor.intercept(next)
</code></pre><p>但 intercept 方法中一定有类似 </p>
<pre><code>response = realChain.proceed(request);
</code></pre><p>也就是一层层连在一起了：</p>
<pre><code>chain1.proceed(request1) -&gt; interceptor1.intercept(chain2) -&gt; chain2.proceed(request2) -&gt; interceptor2.intercept(chain3) ...
</code></pre><p>先一层层下去拦截，到最后一层了，再一层层结束方法返回，最后得到一个 Response </p>
<h3 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h3><p>Interceptor 是 OkHttp 最核心的一个东西，不要误以为它只负责拦截请求进行一些额外的处理（例如 cookie），实际上它把实际的网络请求、缓存、透明压缩等功能都统一了起来，每一个功能都只是一个 Interceptor，它们再连接成一个 Interceptor.Chain，环环相扣，最终圆满完成一次网络请求。</p>
<p><img src="img/okin.png" alt="icon"></p>
<ul>
<li>在配置 OkHttpClient 时设置的 interceptors；</li>
<li>负责失败重试以及重定向的 RetryAndFollowUpInterceptor；</li>
<li>负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的 BridgeInterceptor；</li>
<li>负责读取缓存直接返回、更新缓存的 CacheInterceptor；</li>
<li>负责和服务器建立连接的 ConnectInterceptor；</li>
<li>配置 OkHttpClient 时设置的 networkInterceptors；</li>
<li>负责向服务器发送请求数据、从服务器读取响应数据的 CallServerInterceptor。</li>
</ul>
<p><strong>责任链模式在这个 Interceptor 链条中得到了很好的实践</strong></p>
<h4 id="RetryAndFollowUpInterceptor-重试-重定向"><a href="#RetryAndFollowUpInterceptor-重试-重定向" class="headerlink" title="RetryAndFollowUpInterceptor 重试 重定向"></a>RetryAndFollowUpInterceptor 重试 重定向</h4><p>while(true) 循环，然后通过 followUpCount++ 不超过 20 次，不然就抛出异常。</p>
<h4 id="BridgeInterceptor-CookieJar"><a href="#BridgeInterceptor-CookieJar" class="headerlink" title="BridgeInterceptor CookieJar"></a>BridgeInterceptor CookieJar</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xhdlmy.github.io/2018/09/20/千里之行，始于足下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee&Da">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/kuiba_dacang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XL'Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/20/千里之行，始于足下/" itemprop="url">千里之行 始于足下</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-20T16:15:25+08:00">
                2018-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/随笔/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果学习中容易胡思乱想，容易受他人影响，那么告诉自己，眼到、手到、心到！立马回神，如果是不好理解的硬骨头，不要慌乱、不要烦躁，稳住，一点点进入状态，只要想学习的话，方法总比困难多！不要只是盯着看，是比较容易受到影响并引起烦躁情绪的，不要囫囵吞枣，不然无用功而已！要么要敲代码，要么整理笔记，让大脑同步动起来！</p>
<p>只有当下努力，沉浸才能令我舒服！</p>
<p>当你在啃硬骨头时，想做却又受影响有烦躁情绪时，无法沉浸时，容易“胡思乱想”，比如，今天一天又过去了，却没有完成计划，离自己的目标和期望较远，那么不要想对不起刚组建的小家庭、对不起未来的自己；更需要做的是“自我肯定”，也就是“我不求赢得跟时间的赛跑，我只求认认真真跑完全程”，我相信到达终点蓦然回首时，会是另外一番景象。</p>
<p>但求好事，不问前程。认认真真努力在当下，就算一条汉子。</p>
<p>不那么在意得失，不去想；患得患失是大忌，过度幻想成功了如何如何，会急功近利，人会变得浮躁，如何能沉下心来！当你想得多而做得少时，看看丰满的理想和枯瘦的现实，又将你的自信打击，如此恶心循环，失败-自责-失败；成功就是做到了一点点也是成功，一步一个脚印。</p>
<p>千里之行，始于足下。</p>
<p>学习如此，锻炼也是如此！当你今日是在锻炼中度过了，那么今天就敬重自己是一条汉子！逃避和懒惰等负面情绪滋生是无法解决实际问题的，要解决问题，就是一条路，勇敢面对，努力去做！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/kuiba_dacang.png"
                alt="Lee&Da" />
            
              <p class="site-author-name" itemprop="name">Lee&Da</p>
              <p class="site-description motion-element" itemprop="description">海纳百川 有容乃大 壁立千仞 无欲则刚</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee&Da</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  

  
  

  

  

  

</body>
</html>
